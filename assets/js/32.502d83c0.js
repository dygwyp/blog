(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{567:function(s,n,t){"use strict";t.r(n);var a=t(3),e=Object(a.a)({},(function(){var s=this,n=s.$createElement,t=s._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("blockquote",[t("p",[s._v("本文介绍了如何进行有效的C++编程，以提高编码质量。"),t("br"),s._v("\n本文主要参考的书籍《Effective C++》 [美] Scott Meyers。"),t("br"),s._v("\n备注：原书籍总结了55条方法，本系列文章选取了其中常用的方法。")])]),s._v(" "),t("h2",{attrs:{id:"让自己习惯c"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#让自己习惯c"}},[s._v("#")]),s._v(" 让自己习惯C++")]),s._v(" "),t("h3",{attrs:{id:"_1-视c-为一个语言联邦"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-视c-为一个语言联邦"}},[s._v("#")]),s._v(" 1 视C++为一个语言联邦")]),s._v(" "),t("p",[s._v("如何理解C++语言？最简单的方法是将C++视为一个由相关语言组成的联邦而非单一语言。为了理解C++，需要认识4个次语言：")]),s._v(" "),t("ul",[t("li",[s._v("C"),t("br"),s._v("\nC++以C为基础。区块(blocks)、语句(statements)、预处理(preprocessor)、内置数据类型(built-in data types)、数组(arrays)、指针(pointers)等统统来自C。")]),s._v(" "),t("li",[s._v("Object-Oriented C++"),t("br"),s._v("\n如classes, 封装(encapsulation), 继承(inheritance), 多态(polymorphism), virtual函数等。")]),s._v(" "),t("li",[s._v("Template C++"),t("br"),s._v("\nC++的泛型编程部分。")]),s._v(" "),t("li",[s._v("STL"),t("br"),s._v("\nSTL是个template程序库，它对容器(containers)、迭代器(iterators)、算法(algorithms)以及函数对象(function objects)的规约有极佳的紧密配合与协调。")])]),s._v(" "),t("p",[s._v("Remember:")]),s._v(" "),t("ul",[t("li",[s._v("C++高效编程守则视状况而变化，取决于你使用C++的哪一部分。")])]),s._v(" "),t("h3",{attrs:{id:"_2-尽量以const-enum-inline替换-define"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-尽量以const-enum-inline替换-define"}},[s._v("#")]),s._v(" 2 尽量以const, enum, inline替换#define")]),s._v(" "),t("p",[s._v("这个条款或许改为“宁可以编译器替换预处理器”比较好，因为或许#define不被视为语言的一部分。比如："),t("br"),s._v(" "),t("code",[s._v("#define RATIO 1.6")]),s._v("\n记号名称也许从未被编译器看见；也许在编译器开始处理源码之前它就被预处理器移走了。于是记号名称RATIO有可能没进入记号笔(symbol table)内。"),t("br"),s._v("\n解决之道是以一个常量替换："),t("br"),s._v(" "),t("code",[s._v("const double Ratio = 1.6;")]),s._v("\n作为一个语言常量，Ratio肯定会被编译器所看到，当然会进入记号表内。")]),s._v(" "),t("p",[s._v("Remember:")]),s._v(" "),t("ul",[t("li",[s._v("对于单纯常量，最好以const对象或enums替换#define。")]),s._v(" "),t("li",[s._v("对于形似函数的宏(macros)，最好改用inline函数替换#define。")])]),s._v(" "),t("h3",{attrs:{id:"_3-尽可能使用const"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-尽可能使用const"}},[s._v("#")]),s._v(" 3 尽可能使用const")]),s._v(" "),t("p",[s._v("const允许你指定一个语义约束（指定一个“不该被改动”的对象），而编译器会强制实施这项约束。"),t("br"),s._v("\n举例：")]),s._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('char greeting[] = "Hello";\nchar* p = greeting;                 // non-const pointer, non-const data\nconst char* p = greeting;           // non-const pointer, const data\nchar* const p = greeting;           // const pointer, non-const data\nconst char* const p = greeting;     // const pointer, const data\n\nvoid f1(const Widget* pw);\nvoid f2(Widget const * pw);         // 这两种写法接受的参数类型一样\n')])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br")])]),t("p",[s._v("const语法的特点是：")]),s._v(" "),t("ul",[t("li",[s._v("如果const出现在星号左边，表示被指物是常量；")]),s._v(" "),t("li",[s._v("如果const出现在星号右边，表示指针自身是常量；")]),s._v(" "),t("li",[s._v("如果出现在星号两边，表示被指物和指针两者都是常量。")])]),s._v(" "),t("p",[s._v("const最具威力的用法是面对函数声明时的应用。令函数返回一个常量值，可以降低因客户错误而造成的意外。举例：")]),s._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("class Rational {...};\nconst Rational operator* (const Rational& lhs, const Rational& rhs);\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])]),t("p",[t("strong",[s._v("在const和non-const成员函数中避免重复")]),t("br"),s._v("\n如何实现用non-const调用const函数？")]),s._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("class TextBlock {\npublic:\n    ...\n    const char& operator[] (std::size_t position) const\n    {\n        ...\n        ...\n        return text[position];\n    }\n    char& operator[] (std::size_t position)\n    {\n        return\n            const_cast<char&>(                  // 将op[]返回值的const移除\n                static_cast<const TextBlock&>(*this)[position]);    // 为*this加上const, 调用const op[]\n    }\n}\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br")])]),t("p",[s._v("这里用到了两个转型操作，如注释所见。"),t("br"),s._v("\n注意一点，反向操作是一件错误行为。如果在const函数内调用non-const函数，就是冒了这样的风险：你曾经承诺不改动的那个对象被改动了。")]),s._v(" "),t("p",[s._v("Remember:")]),s._v(" "),t("ul",[t("li",[s._v("将某些东西声明为const可帮助编译器侦测出错误用法。")]),s._v(" "),t("li",[s._v("当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。")])]),s._v(" "),t("h3",{attrs:{id:"_4-确定对象被使用前已被初始化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-确定对象被使用前已被初始化"}},[s._v("#")]),s._v(" 4 确定对象被使用前已被初始化")]),s._v(" "),t("p",[s._v("c++对于初始化的表现反复无常，举例：")]),s._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("int x;\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("在某些语境下x保证会被初始化为0，但在其他语境却不保证。"),t("br"),s._v("\n读取未初始化的值会导致不明确的行为，在某些情景下，仅仅是读取未初始化的值，就能让你的程序终止运行。"),t("br"),s._v("\n我们有一些规则：“对象的初始化动作何时一定发生，何时不一定发生”。  举例："),t("br"),s._v("\n通常如果你使用C pat of C++，而且初始化会造成一些运行期成本，那么就不保证发生初始化。一旦进入non-C parts of C++，规则有些变化。"),t("br"),s._v("\n这解释了为什么array(C part of C++)不保证其内容被初始化，而vector(来自STL part of C++)却有此保证。")]),s._v(" "),t("p",[s._v("最佳的处理办法是：永远在使用对象之前先将它初始化。"),t("br"),s._v("\n至于内置类型以外的，初始化责任落在构造函数身上。规则为：确保每一个构造函数都将对象的每一个成员初始化。举例：")]),s._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("class PhoneNumbers {...};\nclass ABEntry {\npublic:\n    ABEntry(const std::string& name, const std::string& address,\n            const std::list<PhoneNumber>& phones);\nprivate:\n    std::string theName;\n    std::string theAddress;\n    std::list<PhoneNumber> thePhones;\n    int numTimesConsulted;\n};\nABEntry::ABEntry(const std::string& name, const std::string& address,\n                 const std::list<PhoneNumber>& phones)\n{\n    theName = name;             // 这些都是赋值，而非初始化\n    theAddress = address;\n    thePhones = phones;\n    numTimesConsulted = 0;\n}\n\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br")])]),t("p",[s._v("C++规定，对象的成员变量初始化动作发生在进入构造函数本体之前。在ABEntry构造函数内，theName, theAddress和thePhone都不是初始化，而是赋值。"),t("br"),s._v("\n初始化发生的时间更早，发生于这些成员的default构造函数被自动调用之时。但numTimesConsulted并不是如此，它是内置类型。"),t("br"),s._v("\nABEntry构造函数一个较佳的写法是，使用成员初值列替换赋值：")]),s._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("ABEntry::ABEntry(const std::string& name, const std::string& address,\n                 const std::list<PhoneNumber>& phones)\n{\n    theName(name);             // 这些都是初始化\n    theAddress(address);\n    thePhones(phones);\n    numTimesConsulted(0);\n}\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br")])]),t("p",[s._v("Remember:")]),s._v(" "),t("ul",[t("li",[s._v("为内置型对象进行手工初始化，因为C++不保证初始化它们。")]),s._v(" "),t("li",[s._v("构造函数最好使用成员初值列，而不要在构造函数本体内使用赋值操作。初值列列出的成员变量，其排列词序应该和它们在class中的声明词序相同。")]),s._v(" "),t("li",[s._v("为免除“跨编译单元之初始化词序”问题，请以local static对象替换non-local static对象。")])]),s._v(" "),t("h2",{attrs:{id:"构造-析构-赋值运算"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造-析构-赋值运算"}},[s._v("#")]),s._v(" 构造/析构/赋值运算")]),s._v(" "),t("h3",{attrs:{id:"了解c-默默编写并调用哪些函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#了解c-默默编写并调用哪些函数"}},[s._v("#")]),s._v(" 了解C++默默编写并调用哪些函数")]),s._v(" "),t("p",[s._v("如果你写下：")]),s._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("class Empty {};\n// as like 就好像你写下\nclass Empty {\npublic:\n    Empty() {...}                   // 默认构造函数\n    Empty(const Empty& rhs) {...}   // copy构造函数\n    ~Empty() {...}                  // 析构函数，是否该是\n\n    Empty& operator=(const Empty& rhs) {...}    // copy assignment操作符\n};\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br")])]),t("p",[s._v("惟有这些函数被需要，它们才会被编译器创建出来。程序中需要它们是很平常的事。下面代码造成上述每一个函数被编译器产出：")]),s._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("Empty e1;       // default构造函数\n                // 析构函数\nEmpty e2(e1);   // copy构造函数\ne2 = e1;        // copy assignment操作符\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])])])}),[],!1,null,null,null);n.default=e.exports}}]);